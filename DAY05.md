第三章：哈希表 （Hash Table）牺牲了空间 换取了时间
什么时候应该用到哈希法：要快速判断一个元素是否出现在集合里时，就要考虑哈希法。
哈希表是根据关键码的值而直接进行访问的数据结构     直白来讲 数组就是一个哈希表 哈希表中的关键码就是数组的索引下标 通过下标直接访问数组中的元素

哈希函数（Hash Function）
以查询一个名字是否在学校里为例子：
将学生姓名映射到哈希表 就涉及到了哈希函数
哈希函数：把学生的姓名直接映射到哈希表上的索引 然后通过查询索引下标 快速知道这位同学是否在学校里
index = hashFunction(name)
hashFunction = hashCode(name)%tableSize

如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？
此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。
如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。-------哈希碰撞

哈希碰撞（Hash Collisions）
两个元素都映射到了同一个下标索引 叫做哈希碰撞    有两种解决方法:拉链法和线性探测法
数据规模：data size  哈希表大小：table size

拉链法：选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间
线性探测法：使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题

常见的三种哈希结构：1 数组  2 集合（set） 3 映射（map）
set和map分别提供以下数据结构：
set：std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
map：std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）

使用集合来解决哈希表问题时，优先采用unordered_set 因为它的查询和增删效率是最优的。 如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset
在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的



242  有效的字母异位词 用到map
定义一个数组，来记录字符串s里字符出现的次数
定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值设定一个数组为Record 大小为26（因为设置为小写字母 一共有26个字母）
需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25
再遍历字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了
如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作
record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。
最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true

思路要记住 ：先遍历 转换 再用另一个数组去减 如果最后为0 则两个数组一样


ord（）函数以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值


349  两个数组的交集 此时用到set
题目特意说明：输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序
使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set
直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的

使用数组法 将两个数组映射到哈希表中  若哈希表中对应的数乘积大于0 则该元素为两个数组的交集

使用集合法 利用set（）函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等
x & y 表示交集     x | y 表示并集      x - y 表示差集









