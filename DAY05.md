第三章：哈希表 （Hash Table）牺牲了空间 换取了时间
什么时候应该用到哈希法：要快速判断一个元素是否出现在集合里时，就要考虑哈希法。
哈希表是根据关键码的值而直接进行访问的数据结构     直白来讲 数组就是一个哈希表 哈希表中的关键码就是数组的索引下标 通过下标直接访问数组中的元素

哈希函数（Hash Function）
以查询一个名字是否在学校里为例子：
将学生姓名映射到哈希表 就涉及到了哈希函数
哈希函数：把学生的姓名直接映射到哈希表上的索引 然后通过查询索引下标 快速知道这位同学是否在学校里
index = hashFunction(name)
hashFunction = hashCode(name)%tableSize

如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？
此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。
如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。-------哈希碰撞

哈希碰撞（Hash Collisions）
两个元素都映射到了同一个下标索引 叫做哈希碰撞    有两种解决方法:拉链法和线性探测法
数据规模：data size  哈希表大小：table size

拉链法：选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间
线性探测法：使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题

常见的三种哈希结构：1 数组  2 集合（set） 3 映射（map）
set和map分别提供以下数据结构：
set：std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
map：std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）

使用集合来解决哈希表问题时，优先采用unordered_set 因为它的查询和增删效率是最优的。 如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset
在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的



242  有效的字母异位词 用到map
定义一个数组，来记录字符串s里字符出现的次数
定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值设定一个数组为Record 大小为26（因为设置为小写字母 一共有26个字母）
需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25
再遍历字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了
如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作
record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。
最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true

思路要记住 ：先遍历 转换 再用另一个数组去减 如果最后为0 则两个数组一样


ord（）函数以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值


349  两个数组的交集 此时用到set
题目特意说明：输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序
使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set
直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的

使用数组法 将两个数组映射到哈希表中  若哈希表中对应的数乘积大于0 则该元素为两个数组的交集

使用集合法 利用set（）函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等
x & y 表示交集     x | y 表示并集      x - y 表示差集





202 快乐数
题目中说了会 无限循环，那么也就是说求和的过程中，sum会重复出现，所以采用哈希法 来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止
判断sum是否重复出现就可以使用unordered_set

add() 方法用于给集合添加元素，如果添加的元素在集合中已存在，则不执行任何操作
while True 这个语句就直接告诉你判断的结果了，会一直执行循环里的语句
divmod()函数把除数和余数运算结果结合起来，返回一个包含商和余数的元祖 内置函数 divmod(100,10)表示100/10的商和余数
def get_sum(self,n: int) -> int: 
        new_num = 0
        while n:      循环直到n=0时结束
            n, r = divmod(n, 10)  求商和余数 但商可能不是一位数字 所以循环求
            new_num += r ** 2     每次循环只加上余数
        return new_num

写代码时要记得初始化

while(n)表示当n的值不为0时，执行循环语句块。 也就是说，只要n的值为非零，while循环就会一直执行，直到n的值为0时停止循环。 其中n可以是任何条件表达式，当条件表达式的值为非零时，循环会一直执行下去，直到条件表达式的值为0时退出循环。

遇到重复出现 要考虑用到哈希法
数组添加元素用append（） 集合添加元素用set（）

str() 函数将指定的值转换为字符串  求取数字中每位数字的和之类的可以采用这个方法：
n_str = str(n)
for i in n_str:
    new_num+=int(i)**2





1 两数之和
当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法
在这道题中：需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适

使用数组和set来做哈希法的局限。
数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。
此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。

map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）

接下来是map中key和value分别表示什么。

这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。

那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。

所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。

在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中
index() 函数用于从列表中找出某个值第一个匹配项的索引位置
    for i, num in enumerate(nums):
            complement = target - num
            if complement in seen:
                return [nums.index(complement), i]   其中i为数的下标 nums.index()为集合中的下标












